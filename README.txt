Am ales pentru implementarea acestui proiect sa folosesc mai multe fisiere sursa , unul denumit "Doubly_linked_list.h" unde am ales sa pastrez bibliotecile necesare si antetele functiilor din fisierul "Doubly_linked_list.c" si structurile de date folosite in implementari . In fisierul "Doubly_linked_list.c" am pastrat implementarile pentru functiile de prelucrare asupra unei liste dublu inlantuite . In fisierul principal , am ales sa fac functiile si algoritmii necesari in ducerea temei pana la capat . In fisierul "Stack.h" am utilizat niste "guard-uri" , deoarece primeam eroare daca lasam fara acestea . Pe langa aceste "guard-uri" , fisierul contine structura de stiva si antetele functiilor din "Stack.c" . In "Stack.c" am implementat functiile clasice de prelucrare asupra unei stive , preluate fie din cursuri , fie din laborator . In "Node.h" am pus antetul functiei de initializare nod si structura pentru un nod si in "Node.c" am implementat functia de initializare nod . In "main.c" am introdus bibliotecile standard necesare , precum si cele create de mine . Am folosit enum-uri pentru a face diferenta dintre modul "Inserare comanda" si "Inserare text". Strcutura "State" contine elementele care se modifica in timpul executiei programului , documentul de tip lista dublu inlantuita , cursorul , linia si modul , toate de tip int . Urmatoarele functii se adreseaza unei liste dublu inlantuite si au scopul de a crea o linie , de a recalcula size-ul liste , de a intoarce o linie , de a insera o linie in document si de a crea o copie a acestuia . Urmeaza o functie de intializare pentru o structura de tip "State" si de a o returna . Am mai creat cateva functii pentru a-mi facilita implementarea comenzilor si anume , una care intoarce un caracter , alta care gaseste un cuvant , inca una care inlocuieste un cuvant vechi cu unul nou si ultima care sterge liniile goale din fisierul de output . In main am initializat textul din fisier sub forma variabilei "document" , ca o lista de de liste in care fiecare rand era o lista de caractere . Am folosit elemente de tip void in structuri , dar pe care le-am castat in functie de tipul cerut unde era necesar . Prin variabila "mode" am facut trecerea de la modul de inserare la cel de editare . Daca se schimba pe modul de inserare text se adauga o noua linie prin functia insert line . Pentru comanda save am deshis fisierul pentru scriere si am parcurs continutul pentru a-l scrie in el . Pentru comanda quit am eliberat memoria folosita de "document" si am golit stiva "history" pentru a o elibera . La comanda "b" am verificat pozitia cursorului si daca el nu se afla la inceputul liniei se sterge caracterul cerut si se micosreaza pozitia cursorului . Pentru "go line" am citit indexul la care sa se deplaseze , am reinitializat cusorul la primul caracter si am micsorat indexul liniei . LA functia "goto char" am verificat cate argumente primeste si daca erau doua insemna ca se specifica si linia . Pentru "delete line" de asemenea am verificat daca primeste argument si am sters din document linia respectiva . Pentru " delete word" am citit initial cuvantul care urma sa fie sters si i-am gasit pozitia prin functia find word . Daca pozitia era valida inlocuiam cuvantul vechi cu "" care am considerat ca inseamna un "nimic", adica stergerea cuvantului propriu-zis . Analog am folosit si pentru "delete all" doar ca in loc de if am folosit bucla while care trecea prin tot documentul pentru a gasi cuvintele si pentru a le sterge . Pentru "delete" am verificat daca se citeste si numarul de caractere si intr-un ciclu for am parcurs si am sters numarul dat de caractere incepand din pozitia cursorului . Pentru functiile "replace word" si "replace all" am folosit acelasi schelet de cod , singura exceptie fiind ca in loc de "" am folosit noul cuvant . 